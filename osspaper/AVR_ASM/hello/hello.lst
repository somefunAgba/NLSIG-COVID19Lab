gavrasm Gerd's AVR assembler version 4.8 (C)2020 by DG4FAC
----------------------------------------------------------

Path:        D:\AVRA1.4.2\AVR_ASM\hello\
Source file: hello.asm
Hex file:    hello.hex
Eeprom file: hello.eep
Compiled:    24.08.2020, 16:19:54
Pass:        2

     1: ; useful links: http://academy.cba.mit.edu/classes/embedded_programming/index.html
     2: ;http://www.avr-asm-tutorial.net/avr_en/beginner/execution/execution.html
     3: ;http://www.avr-asm-tutorial.net/avr_en/micro_beginner/index.html
     4: ; http://www.avr-asm-tutorial.net/avr_en/starter/starter.html
     5: ; https://www.instructables.com/id/Command-Line-AVR-Tutorials/
     6: 
     7: 
     8: ; hello.asm
     9: ; EXPERIMENT: turn on a LED connected to PORTB5 (PIN 13) on ATMEGA328P
    10: ; ATMEGA-AVR is a relatively simple 8-bit Reduced Instruction Set Computer, or RISC, microcontroller with a Harvard architecture.
    11: ; easier to use and configure than the STM-ARM FAMILY
    12: 
    13: ; % stands for filename.
    14: ; avra %.asm
    15: ; avrdude -D -p m328p -c arduino -P COM5 -U flash:w:%.hex:i
    16: 
    17: 
    18: ;; What we will learn
    19: ;; mnemonics
    20: ; ldi hregister, number
    21: ;; load an 8-bit number (0-255) into a upper half register(16-31)
    22: ; out ioregister, register
    23: ;; copy a number from a working register into an input-output I/O register 
    24: ; rjmp label
    25: ;; relative jump to a line (not more thn 204 instructions(lines) away) in the source code, indicated by label.
    26: ; semi-colon indicates a comment line.
    27: ; case-insensitive, so be careful
    28: 
    29: ; definition file for the ATMEGA328P; makes life easier
    30: ; if we did not include this, we would have to manually add the required definitions in the file in this source code
    31: .include "m328Pdef.inc"
 -> Warning 009: Include defs not necessary, using internal values!
   File: D:\AVRA1.4.2\AVR_ASM\hello\hello.asm, Line: 31
   Source line: .include "m328Pdef.inc"
    32: 
    33: 	.cseg ; code segment for flash memory
    34: 	.org 0x00 ; origin of code segment : here it is the beginning of the flash memory: 0x00
    35: 	
    36: main:
    37: 	; load immediate number into register
    38: 	; a register here is a set of 8bits, meaning 8 locations that can either be 0 or 1
    39: 	; a register here is used as a variable name to store a number
    40: 	; load 0x20 in general purpose working register, r16
    41: 	; we cannot load constants as an operand into i/o registers but can use 
    42: 	; general purpose registers 16 to 31
    43: 	; these registers are specially connected to the ALU. 
    44: 	; so anytime we need the CPU to operate on a value
    45: 	; it should first be placed in one of those
    46: 000000   E200  ldi r16, 0b00100000; 0x20 (hex) or 32 (decimal)
    47: 	
    48: 	; DDRB: Data Direction Register B
    49: 	; copy the contents of r16 into DDRB
    50: 	; ths sets up the bit locations in PORTB:PB0-PB7: 
    51: 	; with 0 as input directed locations 
    52: 	; and those with 1 as output directed
    53: 	; accept i/o mapped register as operand
    54: 000001   B904  out DDRB, r16
    55: 	
    56: 	; copy r16 to PORTB register
    57: 	; 0 now means 0volts and 1 means Vcc=5volts: in this case we only have PB5=1
    58: 000002   B905  out PORTB, r16
    59: 	
    60: ; a line label called loop
    61: loop:
    62: 	; rjmp = relative jump to a label
    63: 	; here this causes an infinite loop
    64: 	; since the jumping continues forever
    65: 	; allowing PB5 to remain set at 1,
    66: 	; hence the LED stays on.
    67: 000003   CFFF  rjmp loop    
    68: 	; removing this infinite-loop may cause a sort of undefined behaviour, but it is optional.
    69: 	
    70: ;; Conclusion (rephrase)
    71: ; We have seen how to use assembler directives like .include, .cseg and .org. 
    72: ; We also saw how to load constants to general purpose working registers using 
    73: ; the instruction ldi and write values to I/O registers using the instruction out. 
    74: ; Finally, we saw how to define labels and control program flow with the instruction rjmp.	

List of symbols:
Type nDef nUsed             Decimalval           Hexval Name
  T     1     1                    162               A2 ATMEGA328P
  L     1     0                      0               00 MAIN
  L     1     2                      3               03 LOOP
  C     1     0                     20               14 NOW_Y
  C     1     0                      8               08 NOW_M
  C     1     0                     24               18 NOW_D
  C     1     0                  44067             AC23 NOW_I
   No macros.

Program             :        4 words.
Constants           :        0 words.
Total program memory:        4 words.
Eeprom space        :        0 bytes.
Data segment        :        0 bytes.
Compilation completed, no errors.
Compilation endet 24.08.2020, 16:19:54
